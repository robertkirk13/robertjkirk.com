---
title: "Understanding PID Controllers"
date: "2025-11-30"
formattedDate: "November 30, 2025"
description: "An interactive exploration of proportional, integral, and derivative control systems."
readingTime: 12
tags: ["controls", "engineering", "interactive"]
---

import MotorDemo from "../../components/pid/MotorDemo";
import PIDDemo from "../../components/pid/PIDDemo";
import OvenController from "../../components/pid/OvenController";
import InvertedPendulum from "../../components/pid/InvertedPendulum";
import CascadeDiagram from "../../components/pid/CascadeDiagram";
import ControlLoopDiagram from "../../components/pid/ControlLoopDiagram";
import TuningChallenge from "../../components/pid/TuningChallenge";
import ComparisonPlayground from "../../components/pid/ComparisonPlayground";

You've probably used a PID controller today without knowing it. They're in your car's cruise control, your home thermostat, the quadcopter you flew last weekend, and the robotic arm that assembled your phone. PID controllers are everywhere because they solve a fundamental problem: **how do you get something to go where you want it to go, and stay there?**

<div className="flex items-center gap-3 my-6">
  <div className="w-5 h-5 rounded-full bg-orange-500 border-2 border-orange-300 flex-shrink-0 shadow-lg shadow-orange-500/30" style={{animation: "pulse-size 2s ease-in-out infinite"}} />
  <span className="text-zinc-400 text-sm">
    <span className="text-orange-400 font-medium">Orange elements are interactive</span> â€” click or drag to explore
  </span>
</div>

<style>{`
  @keyframes pulse-size {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.25); }
  }
`}</style>

In this post, we're going to build an intuition for how PID controllers work. We'll start with the simplest possible controller and gradually add complexity. By the end, you'll understand not just *what* each term does, but *why* it's needed.

---

## The Problem: Turning a Motor

Let's start with something concrete. Imagine you have a motor attached to a <span className="text-blue-400 italic font-semibold text-[1.1em]" style={{fontFamily: '"Times New Roman", Georgia, serif'}}>pointer</span>, like a compass needle. Your job is to make the pointer point at a <span className="text-orange-400 italic font-semibold text-[1.1em]" style={{fontFamily: '"Times New Roman", Georgia, serif'}}>target</span> angle. Sounds simple enough: just tell the motor to turn until it reaches the target, right?

The catch is **inertia**. The pointer has mass, and mass doesn't like to change direction. If you're spinning toward the target and cut the power when you arrive, you'll overshoot. The momentum you built up carries you past where you wanted to stop.

<MotorDemo client:load />

See the problem? The motor has no idea it should slow down as it approaches the target. It's running at full speed right up until it arrives, then wondering why it can't stop. We need something smarter.

---

## Proportional Control: The "P" in PID

The first insight is simple: **the further you are from the target, the harder you should push**. If you're 90Â° away, apply a lot of power. If you're only 2Â° away, apply just a little. This is called **proportional control** because the output is proportional to the error.

<div className="py-6 my-6 text-center text-xl">
$$
\textcolor{#e879f9}{Output} \;\;=\;\; \textcolor{#60a5fa}{K_p} \cdot \textcolor{#f87171}{error}
$$
</div>

Where **Error** = Target &minus; Current Position, and **Kp** is a gain that determines how aggressive the response is.

Here's how the control loop works:

<ControlLoopDiagram client:load />

The system continuously:
1. **Measures** the current position (feedback)
2. **Computes** the error = target âˆ’ current
3. **Outputs** torque proportional to that error
4. Repeat at ~60 times per second

This creates a **closed-loop system**&mdash;the controller constantly adjusts based on what it observes. Now let's see it in action:

<PIDDemo client:load initialKp={1.5} />

Play with the Kp slider. Notice that there's a tradeoff:

- **Too low**: The system is sluggish and may not even reach the target if there's any friction
- **Too high**: The system overshoots and oscillates, potentially getting worse over time

This is the fundamental limitation of proportional control. You're asking one number to do two jobs: respond quickly AND stop accurately. It can't do both.

---

## Derivative Control: The "D" in PID

The proportional term looks at where you are. But what if we could also look at **how fast you're approaching the target**? If you're racing toward the target at high speed, you should start braking early. If you're crawling toward it, you don't need as much braking.

This is what the **derivative term** does&mdash;it responds to the *rate of change* of the error.

<div className="py-6 my-6 text-center text-xl">
$$
\textcolor{#e879f9}{Output} \;\;=\;\; \textcolor{#60a5fa}{K_p} \cdot \textcolor{#f87171}{error} \;\;+\;\; \textcolor{#c084fc}{K_d} \cdot \textcolor{#f87171}{\frac{d(error)}{dt}}
$$
</div>

If you're approaching the target quickly, the derivative term applies a braking force. It's like anticipatory braking: you don't wait until you're at the stop sign to brake&mdash;you start slowing down as you approach. The purple arrow shows the direction of motion&mdash;watch how the D term provides opposing force.

<PIDDemo client:load enableD={true} enableNoise={true} initialKp={2.0} initialKd={0.8} />

Notice how adding the D term dramatically reduces oscillation! The system now settles smoothly to the target instead of bouncing back and forth. Try setting Kd to 0 to see the difference&mdash;the oscillation returns immediately.

### The Noise Problem

Try enabling the **Noise** button to see why the D term can be problematic in real systems. Because D responds to *changes* in the error, it amplifies any sensor noise. In real applications, this often requires filtering the derivative signal or limiting D's contribution. This is why many practitioners recommend starting with just PI control and only adding D when necessary.

---

## The Steady-State Error Problem

We've solved the oscillation problem with PD control, but there's another issue lurking. Let's add a mass to the end of the pointer. Watch what happens&mdash;the pointer can't quite reach the target:

<PIDDemo client:load enableD={true} enableMass={true} initialKp={2.0} initialKd={0.8} initialMass={0.5} />

This persistent gap is called **steady-state error**. The mass pulls the pointer down, and the PD controller needs *some* error to generate enough force to hold the mass up. The heavier the mass, the bigger the error needed. Try adjusting the mass slider to see this effect&mdash;and notice how increasing Kp reduces the error but can't eliminate it entirely.

Neither P nor D can fix this problem. D only responds to *changes* in error&mdash;once the system has settled (even in the wrong place), there's no change to respond to. We need something else.

---

## Integral Control: The "I" in PID

Here's the key insight: if the error persists, we should keep adding force. Even a small error, given enough time, should result in a large correction. This is what the **integral term** does&mdash;it sums up all the past errors.

<div className="py-6 my-6 text-center text-xl">
$$
\textcolor{#e879f9}{Output} \;\;=\;\; \textcolor{#60a5fa}{K_p} \cdot \textcolor{#f87171}{error} \;\;+\;\; \textcolor{#c084fc}{K_d} \cdot \textcolor{#f87171}{\frac{d(error)}{dt}} \;\;+\;\; \textcolor{#4ade80}{K_i} \cdot \textcolor{#f87171}{\int error \, dt}
$$
</div>

Think of it like this: the integral term is *patient*. It doesn't care if the error is small right now. If that small error has been there for a while, the integral builds up and eventually overwhelms any disturbance.

<PIDDemo client:load enableD={true} enableI={true} enableMass={true} enableNoise={true} showClampingToggle={true} initialKp={2.0} initialKd={0.8} initialKi={0.5} initialMass={0.5} />

The integral term eliminates steady-state error beautifully! Now the pointer reaches the target exactly, even with the mass pulling it down.

### Integral Windup

But there's a catch: the integral term can cause problems of its own. **To see windup in action:**

1. Click the **lock icon** (turns orange) to hold the pointer in place&mdash;this simulates a blocked motor
2. Move the target to the opposite side
3. Wait a few seconds while the integral accumulates
4. Click the lock again to release&mdash;watch the pointer violently overshoot and oscillate!

What happened? While the pointer was blocked, the PID controller kept trying to reach the target. The integral accumulated a *huge* value because the error persisted. When the blockage was removed, all that wound-up integral caused massive overshoot. This is **integral windup**&mdash;it happens during startup, when actuators saturate, or when something physically blocks the mechanism.

**Now try again with clamping enabled:**

1. Click reset, then click the **clamp icon** (turns green) to enable clamping
2. Enable the **lock** (orange) again
3. Move the target to the opposite side and wait
4. Release the lock&mdash;much better behavior!

With clamping enabled (green), the integral is limited, preventing runaway accumulation.

**Other anti-windup strategies include:**

- **Conditional integration**: Only accumulate integral when close to the target
- **Back-calculation**: Reduce integral when output saturates  
- **Recency-weighted integration**: Give more weight to recent errors, letting old errors "decay"

Each approach has tradeoffs, but clamping is the most common starting point because it's simple and effective.

---

## Beyond the Pointer: Temperature Control

Let's see how the same principles apply to a completely different system: controlling the temperature of an oven. This is closer to what you'd find in a real kitchen oven, a reflow soldering station, or an industrial furnace.

<OvenController client:load />

Notice something interesting: this controller only uses **P and I**&mdash;no derivative term at all! Why does that work here?

The key is that thermal systems have **natural damping**. Heat dissipates gradually, and the thermal mass of the oven acts like a built-in low-pass filter. There's no "momentum" that would cause the temperature to overshoot wildly like our motor pointer. The system is inherently sluggish.

This sluggishness means:
- **D isn't needed** for damping&mdash;the physics provides it
- **I is essential**&mdash;we need to eliminate steady-state error from heat loss
- **P provides** the basic responsiveness

Try opening the door to see disturbance rejection! Watch how the integral term builds up to compensate for the increased heat loss.

### Conditional Integration

Try enabling **Conditional I** (the button with the circle icon). With this enabled, the integral only accumulates when the temperature is within 50Â° of the target. This prevents the integral from winding up during the initial heating phase when the error is huge.

Watch the difference: without conditional I, the oven may overshoot slightly during startup because the integral accumulated while far from target. With conditional I enabled, the integral only kicks in during the final approach, providing a cleaner response.

This is a classic example of when PI control is not just sufficient, but preferable&mdash;adding D would just amplify sensor noise without providing much benefit.

---

## Balancing Act: An Inverted Pendulum

For our final example, let's look at one of the most dramatic demonstrations of PID control: balancing an inverted pendulum. This is the classic "broom balancing on your palm" problem, and it's the same principle behind Segways and rocket landing.

<InvertedPendulum client:load showPositionControl={false} />

The pendulum balances! But wait&mdash;watch what happens over time. Click the cart to poke it and observe: eventually the cart **crashes into the edge of the track**. The PD controller is doing its job of keeping the pendulum upright, but it has no concept of *where* the cart is on the track.

This is the classic problem of **cascaded control**. We have one controller for the angle, but we need *another* controller to manage position. The solution is to add a second PD loop:

<CascadeDiagram client:load />

Here's the key insight. Without the outer position loop, the inner angle loop always tries to keep the pendulum at 0Â° (vertical). But with the outer loop, we *bias* that target slightly off-vertical to push the cart back toward center:

```js
// Outer loop: where should the pendulum lean?
positionError = targetPosition - cartPosition
targetAngle = Kp_pos * positionError + Kd_pos * cartVelocity

// Inner loop: achieve that lean angle
angleError = targetAngle - pendulumAngle  // NOT just "0 - angle"!
motorForce = Kp_angle * angleError + Kd_angle * angularVelocity
```

If the cart drifts right, the position loop outputs a small **negative target angle**&mdash;telling the pendulum to lean slightly left. This creates a force that pushes the cart back. The inner angle loop doesn't care *why* it's being told to lean; it just does its job of achieving that angle smoothly.

<InvertedPendulum client:load showPositionControl={true} />

Now we have two control loops working together:

1. **Angle Control** (Kp<sub>Î¸</sub>, Kd<sub>Î¸</sub>): Fast inner loop that keeps the pendulum at whatever angle it's told
2. **Position Control** (Kp<sub>x</sub>, Kd<sub>x</sub>): Slower outer loop that adjusts that target angle to control cart position

The position controller adds a gentle bias to the angle controller's target, nudging the cart back toward center without destabilizing the balance.

Try these experiments:
- **Drag the orange handle** to set a new target position and watch the cart smoothly move there while staying balanced
- **Click the cart** to poke it and watch both controllers work to recover
- **Set position Kp<sub>x</sub> = 0** to see it drift off track like before
- **Turn off control** to see how quickly the system is unstable
- **Set Kd<sub>Î¸</sub> = 0** to see angle oscillations grow and cause failure

This cascaded structure&mdash;an inner loop for fast dynamics (angle) and an outer loop for slower dynamics (position)&mdash;is extremely common in real control systems. Quadcopters use it (attitude inner loop, position outer loop), as do robotic arms and self-balancing robots.

---

## Summary: The Complete Picture

Now you've seen all three terms in action:

| Term | Looks at | Effect | Fixes | Can cause |
|------|----------|--------|-------|-----------|
| **P** | Present error | Push toward target | Slow response | Overshoot, oscillation |
| **D** | Future error (rate) | Brake before arrival | Overshoot, oscillation | Noise sensitivity |
| **I** | Past error (sum) | Eliminate steady-state error | Steady-state error | Windup, slow response |

---

## Tuning Challenge

The art of PID control is choosing Kp, Ki, and Kd to work in harmony. Each system is different&mdash;the mass of the pointer, the power of the motor, the amount of friction&mdash;all affect what gains work best.

**Can you tune a PID controller?** Try each challenge and beat the par time. The gains start at non-functional values&mdash;you'll need to figure out what works!

<TuningChallenge client:load />

**Hints for each challenge:**

- **Basics**: P alone can solve this, but D makes it cleaner
- **Weighted**: The mass creates steady-state error&mdash;you'll need I to fix it
- **Big Step**: Large movements need careful D tuning to avoid overshoot
- **Heavy**: Maximum mass requires all three terms working together

**General tuning approach:**

1. **Start with P only**: Increase until it responds but oscillates
2. **Add D**: Dampen the oscillation until minimal overshoot
3. **Add I if needed**: Only when there's persistent error (mass challenges)

---

## Comparison Playground

Finally, here's a playground where you can compare P, PD, and PID controllers side-by-side. All three controllers are trying to reach the same target&mdash;watch how they differ:

<ComparisonPlayground client:load />

Click **Random Target** (ðŸŽ²) to see how each handles step changes. Increase the **Mass** to add a disturbance and observe:

- **P** (blue): Gets close but oscillates, and has steady-state error when mass is added
- **PD** (purple): Settles quickly with minimal overshoot, but still has steady-state error with mass
- **PID** (green): Smooth response AND eliminates steady-state error&mdash;the integral term compensates for the mass

This is the power of combining all three terms: P provides responsiveness, D provides damping, and I eliminates persistent error.

---

## What We Learned

Let's recap the intuition we've built:

**Proportional (P)**: "Push toward the target, harder when far away"
- Good for: fast initial response
- Bad at: reaching the target exactly (steady-state error), not overshooting

**Derivative (D)**: "If we're approaching fast, start braking"
- Good for: reducing overshoot, stabilizing oscillation
- Bad at: handling noisy measurements

**Integral (I)**: "If we've been wrong for a while, try harder"
- Good for: eliminating persistent error, overcoming disturbances
- Bad at: responding quickly (can cause windup and slow oscillation)

The magic of PID is that these three simple terms, combined properly, can control an enormous variety of systems&mdash;from car engines to chemical plants to the autopilot in aircraft.

---

## Going Further

PID is just the beginning. Once you understand these fundamentals, there's a whole world of control theory to explore:

- **Feedforward control**: Don't just react to error&mdash;predict what input you'll need
- **Gain scheduling**: Use different gains depending on operating conditions
- **Model predictive control**: Optimize over a future time horizon
- **State-space control**: Control multiple variables simultaneously

But PID remains the workhorse of industrial control for good reason: it's simple, robust, and with proper tuning, good enough for the vast majority of applications.

---

*This post was inspired by the amazing interactive explanations at [samwho.dev](https://samwho.dev/) and [ciechanow.ski](https://ciechanow.ski/).*
